import { prisma } from "../../../../generated/prisma-client";
import {
  filterExtensionDefinitions,
  typeContainsSelectionSet
} from "graphql-tools";

const CHECKING = "CHECKING";
const CHECKED = "CHECKED";
const COMMENT_WARNING = "COMMENT_WARNING";
const POST_WARNING = "POST_WARNING";
const COMMENT_BLACK_LIST = "COMMENT_BLACK_LIST";
const POST_BLACK_LIST = "POST_BLACK_LIST";

//TO DO
//1.status ÏÉÅÌÉúÍ∞í Ï∂îÍ∞Ä(=> Post_STOP, COMMENT_STOP, ALL_STOP, nomar_STATE)
//2.Îã¨Î†• APIÎ•º ÏÇ¨Ïö©ÌïòÏó¨, ÌòÑÏû¨Îäî new DataÎ°ú ÎêòÏñ¥ÏûàÎäîÍ≤ÉÏùÑ ÎØ∏ÎûòÏùò ÏãúÍ∞ÑÏúºÎ°ú Ï†ÄÏû•ÏãúÌÇ§Îäî Í≤É
//3.ÏòàÏïΩÏãúÍ∞ÑÍ≥º ÏßÄÏ†ïÌï¥ÎÜìÏùÄ ÏãúÍ∞ÑÏù¥ ÎßûÎãøÏùÑÎïå ÎòêÎäî ÎÑòÏóàÏùÑÎïå userÏùò status 1Î≤à ÏÉÅÌÉúÍ∞íÏ§ë ÌïòÎÇòÎ°ú Î≥ÄÍ≤ΩÏãúÌÇ§Îäî Ïùº

export default {
  Mutation: {
    editReport: async (_, args, { request, isAuthenticated }) => {
      isAuthenticated(request);
      const { reportId, offenderId, episodeId, status } = args;

      const { user } = request;

      //ÎßàÏä§ÌÑ∞ Í≥ÑÏ†ïÏù∏ÏßÄ ÌôïÏù∏
      const isMasterUser = await prisma.$exists.user({
        AND: [{ id: user.id }, { rank: "master" }]
      });

      try {
        if (isMasterUser) {
          await prisma.updateReport({
            where: { id: reportId },
            data: {
              status
            }
          });

          //Ïã†Í≥†Ï≤òÎ¶¨Î•º ÏôÑÎ£åÌïòÍ≥† ÎÇúÌõÑ Ìï¥ÏïºÌï† Ïùº
          //Ïã†Í≥†Ï≤òÎ¶¨Î•º ÌôïÏ†ïÎãπÌïú offenderÏùò idÎ•º Ï∂îÏ†ÅÌï¥ÏÑú, Í∑∏ idÏùò reportÌïÑÎìúÏ§ëÏóêÏÑú comment_waring or comment_warningÏù¥ 3Í∞ú Ïù¥ÏÉÅÏù∏ÏßÄ ÌôïÏù∏ÌïòÎäî ÏûëÏóÖ
          //back_listÍ∞Ä 1Í∞úÏù¥ÏÉÅÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥ÏÑú
          //Í∑∏Í≤ÉÏóê ÎßûÎäî ÏÉÅÌÉúÍ∞í Ï†ÑÌôòÏù¥ ÌïÑÏöîÌï®
          if (status !== CHECKED) {
            if (status === COMMENT_WARNING) {
              //ÎåìÍ∏Ä Ïã†Í≥†ÎãπÌïú ÏÇ¨ÎûåÏùÑ ÎåìÍ∏Ä idÎ•º Í∞ÄÏßÄÍ≥† Ï∞æÎäî ÏûëÏóÖ
              const offender = await prisma.users({
                where: { comments_some: { id: offenderId } }
              });

              //ÎåìÍ∏Ä ÏûëÏÑ±ÏûêÏù∏ offenderÎ•º Í∞ÄÏßÄÍ≥† Ïã†Í≥†Í±¥Îì§ÏùÑ Í∞ÄÏßÄÍ≥†Ïò¥
              const reportListOfOffender = await prisma.reports({
                where: { offender: { user: { id: offender[0].id } } }
              });

              let newArr = [];
              reportListOfOffender.map((filter) => {
                if (filter.status === COMMENT_WARNING) {
                  newArr.push(filter.status);
                }
              });

              if (newArr.length >= 3) {
                await prisma.updateUser({
                  where: { id: offender[0].id },
                  data: {
                    status: "COMMENT_STOP",
                    //new Date()Î∂ÄÎ∂ÑÏùÑ ÎØ∏ÎûòÏóê Îã¨Î†• apiÎ°ú ÎåÄÏ≤¥Ìï¥ÏïºÌï®
                    commentWriteTimer: JSON.stringify(new Date())
                  }
                });
              }
            } else if (status === POST_WARNING) {
              //Ìï¥Îãπ Ìè¨Ïä§Ìä∏Î•º Ïò¨Î¶∞ Ïã†Í≥†ÌåÄ
              const offenderTeam = await prisma.users({
                where: { posts_some: { episodes_some: { id: episodeId } } }
              });

              //Ìï¥Îãπ Ïã†Í≥†ÎãπÌïú ÌåÄÏùò ÏóêÌîºÏÜåÎìúÎ•º Ï∞æÎäî ÏΩîÎìú
              const reportListOfOffenderTeam = await prisma.reports({
                where: { episode: { id: episodeId } }
              });

              let newArr = [];
              reportListOfOffenderTeam.map((filter) => {
                if (filter.status === POST_WARNING) {
                  newArr.push(filter.status);
                }
              });

              if (newArr.length >= 3) {
                await prisma.updateUser({
                  where: {
                    id: offenderTeam[0].id
                  },
                  data: {
                    status: "POST_STOP",
                    postWriteTimer: JSON.stringify(new Date())
                  }
                });
              }
            } else if (status === COMMENT_BLACK_LIST) {
              const user = await prisma.users({
                where: { comments_some: { id: offenderId } }
              });

              await prisma.updateUser({
                where: { id: user[0].id },
                data: {
                  status: "COMMENT_STOP",
                  commentWriteTimer: JSON.stringify(new Date())
                }
              });
            } else if (status === POST_BLACK_LIST) {
              const user = await prisma.users({
                where: { posts_some: { episodes_some: { id: episodeId } } }
              });

              await prisma.updateUser({
                where: { id: user[0].id },
                data: {
                  status: "POST_STOP",
                  postWriteTimer: JSON.stringify(new Date())
                }
              });
            }
          }
          return true;
        } else {
          throw Error("Í∞úÎ∞úÏûêÏïº ÏùºÌïòÏûêü•µ");
        }
      } catch (e) {
        console.log(e);
        return false;
      }
    }
  }
};
